{"version":3,"sources":["smart-table.min.js"],"names":["ng","undefined","module","run","$templateCache","put","constant","pagination","template","itemsByPage","displayedPages","search","delay","inputEvent","trimSearch","select","mode","selectedClass","sort","ascentClass","descentClass","descendingFirst","skipNatural","pipe","controller","$scope","$parse","$filter","$attrs","$window","copyRefs","src","concat","updateSafeCopy","safeCopy","safeGetter","pipeAfterSafeCopy","ctrl","deepDelete","object","path","indexOf","partials","split","key","pop","parentPath","join","parentObject","Object","keys","length","filtered","lastSelected","propertyName","stTable","displayGetter","displaySetter","assign","orderBy","filter","tableState","start","totalItemCount","this","stSafeSrc","$watch","safeSrc","newValue","oldValue","sortBy","predicate","reverse","isFunction","functionName","name","input","comparator","predicateObject","prop","output","number","numberOfPages","Math","ceil","slice","parseInt","row","rows","index","isSelected","getFilteredCollection","setFilterFunction","filterName","setSortFunction","sortFunctionName","preventPipeOnWatch","directive","restrict","link","scope","element","attr","stSetFilter","stSetSort","stConfig","$timeout","require","tableCtrl","promise","throttle","stDelay","event","stInputEvent","$observe","value","isString","trim","predicateExpression","stSearch","bind","evt","originalEvent","cancel","target","stSelectMode","$apply","addClass","removeClass","func","getter","isArray","stSort","sortDefault","classAscent","stClassAscent","classDescent","stClassDescent","stateClasses","stSkipNatural","stDescendingFirst","stSortDefault","$eval","stItemsByPage","stDisplayedPages","stPageChange","templateUrl","attrs","stTemplate","redraw","end","i","paginationState","prevPage","currentPage","floor","max","abs","pages","numPages","push","newPage","setItemsByPage","val","selectPage","page","config","stPipe","pre","pipePromise","context","scrollTo","offsetTop","post","angular"],"mappings":"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","file":"smart-table.min.js","sourcesContent":["(function (ng, undefined){\n    'use strict';\n\nng.module('smart-table', []).run(['$templateCache', function ($templateCache) {\n    $templateCache.put('template/smart-table/pagination.html',\n        '<nav ng-if=\"numPages && pages.length >= 2\"><ul class=\"pagination\">' +\n        '<li ng-repeat=\"page in pages\" ng-class=\"{active: page==currentPage}\"><a href=\"#\" ng-click=\"selectPage(page); $event.preventDefault(); $event.stopPropagation();\">{{page}}</a></li>' +\n        '</ul></nav>');\n}]);\n\n\nng.module('smart-table')\n  .constant('stConfig', {\n    pagination: {\n      template: 'template/smart-table/pagination.html',\n      itemsByPage: 10,\n      displayedPages: 5\n    },\n    search: {\n      delay: 400, // ms\n      inputEvent: 'input',\n      trimSearch: false\n    },\n    select: {\n      mode: 'single',\n      selectedClass: 'st-selected'\n    },\n    sort: {\n      ascentClass: 'st-sort-ascent',\n      descentClass: 'st-sort-descent',\n      descendingFirst: false,\n      skipNatural: false,\n      delay:300\n    },\n    pipe: {\n      delay: 100 //ms\n    }\n  });\nng.module('smart-table').controller('stTableController', [\n  '$scope',\n  '$parse',\n  '$filter',\n  '$attrs',\n  '$window',\n  function StTableController($scope, $parse, $filter, $attrs, $window) {\n    var propertyName = $attrs.stTable;\n    var displayGetter = $parse(propertyName);\n    var displaySetter = displayGetter.assign;\n    var safeGetter;\n    var orderBy = $filter('orderBy');\n    var filter = $filter('filter');\n    var safeCopy = copyRefs(displayGetter($scope));\n    var tableState = {\n      sort: {},\n      search: {},\n      pagination: { start: 0, totalItemCount: 0 }\n    };\n    var filtered;\n    var pipeAfterSafeCopy = true;\n    var ctrl = this;\n    var lastSelected;\n\n    function copyRefs(src) {\n      return src ? [].concat(src) : [];\n    }\n\n    function updateSafeCopy() {\n      safeCopy = copyRefs(safeGetter($scope));\n      if (pipeAfterSafeCopy === true) {\n        ctrl.pipe();\n      }\n    }\n\n    function deepDelete(object, path) {\n      if (path.indexOf('.') != -1) {\n        var partials = path.split('.');\n        var key = partials.pop();\n        var parentPath = partials.join('.');\n        var parentObject = $parse(parentPath)(object);\n        delete parentObject[key];\n        if (Object.keys(parentObject).length == 0) {\n          deepDelete(object, parentPath);\n        }\n      } else {\n        delete object[path];\n      }\n    }\n\n    if ($attrs.stSafeSrc) {\n      safeGetter = $parse($attrs.stSafeSrc);\n      $scope.$watch(\n        function() {\n          var safeSrc = safeGetter($scope);\n          return safeSrc && safeSrc.length ? safeSrc[0] : undefined;\n        },\n        function(newValue, oldValue) {\n          if (newValue !== oldValue) {\n            updateSafeCopy();\n          }\n        }\n      );\n      $scope.$watch(\n        function() {\n          var safeSrc = safeGetter($scope);\n          return safeSrc ? safeSrc.length : 0;\n        },\n        function(newValue, oldValue) {\n          if (newValue !== safeCopy.length) {\n            updateSafeCopy();\n          }\n        }\n      );\n      $scope.$watch(\n        function() {\n          return safeGetter($scope);\n        },\n        function(newValue, oldValue) {\n          if (newValue !== oldValue) {\n            tableState.pagination.start = 0;\n            updateSafeCopy();\n          }\n        }\n      );\n    }\n\n    this.$window = $window;\n\n    /**\n     * sort the rows\n     * @param {Function | String} predicate - function or string which will be used as predicate for the sorting\n     * @param [reverse] - if you want to reverse the order\n     */\n    this.sortBy = function sortBy(predicate, reverse) {\n      tableState.sort.predicate = predicate;\n      tableState.sort.reverse = reverse === true;\n\n      if (ng.isFunction(predicate)) {\n        tableState.sort.functionName = predicate.name;\n      } else {\n        delete tableState.sort.functionName;\n      }\n\n      tableState.pagination.start = 0;\n      return this.pipe();\n    };\n\n    /**\n     * search matching rows\n     * @param {String} input - the input string\n     * @param {String} [predicate] - the property name against you want to check the match, otherwise it will search on all properties\n     * @param {String | Function } [comparator] - a comparator to pass to the filter for the (pass true for stric mode)\n     */\n    this.search = function search(input, predicate, comparator) {\n      var predicateObject = tableState.search.predicateObject || {};\n      var prop = predicate ? predicate : '$';\n\n      $parse(prop).assign(predicateObject, input);\n      // to avoid to filter out null value\n      if (!input) {\n        deepDelete(predicateObject, prop);\n      }\n      tableState.search.predicateObject = predicateObject;\n      tableState.pagination.start = 0;\n      return this.pipe();\n    };\n\n    /**\n     * this will chain the operations of sorting and filtering based on the current table state (sort options, filtering, ect)\n     */\n    this.pipe = function pipe() {\n      var pagination = tableState.pagination;\n      var output;\n      filtered = tableState.search.predicateObject\n        ? filter(safeCopy, tableState.search.predicateObject)\n        : safeCopy;\n      if (tableState.sort.predicate) {\n        filtered = orderBy(\n          filtered,\n          tableState.sort.predicate,\n          tableState.sort.reverse\n        );\n      }\n      pagination.totalItemCount = filtered.length;\n      if (pagination.number !== undefined) {\n        pagination.numberOfPages = filtered.length > 0\n          ? Math.ceil(filtered.length / pagination.number)\n          : 1;\n        pagination.start = pagination.start >= filtered.length\n          ? (pagination.numberOfPages - 1) * pagination.number\n          : pagination.start;\n        output = filtered.slice(\n          pagination.start,\n          pagination.start + parseInt(pagination.number)\n        );\n      }\n      displaySetter($scope, output || filtered);\n    };\n\n    /**\n     * select a dataRow (it will add the attribute isSelected to the row object)\n     * @param {Object} row - the row to select\n     * @param {String} [mode] - \"single\" or \"multiple\" (multiple by default)\n     */\n    this.select = function select(row, mode) {\n      var rows = copyRefs(displayGetter($scope));\n      var index = rows.indexOf(row);\n      if (index !== -1) {\n        if (mode === 'single') {\n          row.isSelected = row.isSelected !== true;\n          if (lastSelected) {\n            lastSelected.isSelected = false;\n          }\n          lastSelected = row.isSelected === true ? row : undefined;\n        } else {\n          rows[index].isSelected = !rows[index].isSelected;\n        }\n      }\n    };\n\n    /**\n     * take a slice of the current sorted/filtered collection (pagination)\n     *\n     * @param {Number} start - start index of the slice\n     * @param {Number} number - the number of item in the slice\n     */\n    this.slice = function splice(start, number) {\n      tableState.pagination.start = start;\n      tableState.pagination.number = number;\n      return this.pipe();\n    };\n\n    /**\n     * return the current state of the table\n     * @returns {{sort: {}, search: {}, pagination: {start: number}}}\n     */\n    this.tableState = function getTableState() {\n      return tableState;\n    };\n\n    this.getFilteredCollection = function getFilteredCollection() {\n      return filtered || safeCopy;\n    };\n\n    /**\n     * Use a different filter function than the angular FilterFilter\n     * @param filterName the name under which the custom filter is registered\n     */\n    this.setFilterFunction = function setFilterFunction(filterName) {\n      filter = $filter(filterName);\n    };\n\n    /**\n     * Use a different function than the angular orderBy\n     * @param sortFunctionName the name under which the custom order function is registered\n     */\n    this.setSortFunction = function setSortFunction(sortFunctionName) {\n      orderBy = $filter(sortFunctionName);\n    };\n\n    /**\n     * Usually when the safe copy is updated the pipe function is called.\n     * Calling this method will prevent it, which is something required when using a custom pipe function\n     */\n    this.preventPipeOnWatch = function preventPipe() {\n      pipeAfterSafeCopy = false;\n    };\n  }\n]).directive('stTable', function() {\n  return {\n    restrict: 'A',\n    controller: 'stTableController',\n    link: function(scope, element, attr, ctrl) {\n      if (attr.stSetFilter) {\n        ctrl.setFilterFunction(attr.stSetFilter);\n      }\n\n      if (attr.stSetSort) {\n        ctrl.setSortFunction(attr.stSetSort);\n      }\n    }\n  };\n});\n\nng.module('smart-table')\n  .directive('stSearch', ['stConfig', '$timeout','$parse', function (stConfig, $timeout, $parse) {\n    return {\n      require: '^stTable',\n      link: function (scope, element, attr, ctrl) {\n        var tableCtrl = ctrl;\n        var promise = null;\n        var throttle = attr.stDelay || stConfig.search.delay;\n        var event = attr.stInputEvent || stConfig.search.inputEvent;\n        var trimSearch = attr.trimSearch || stConfig.search.trimSearch;\n\n        attr.$observe('stSearch', function (newValue, oldValue) {\n          var input = element[0].value;\n          if (newValue !== oldValue && input) {\n            ctrl.tableState().search = {};\n            input = ng.isString(input) && trimSearch ? input.trim() : input;\n            tableCtrl.search(input, newValue);\n          }\n        });\n\n        //table state -> view\n        scope.$watch(function () {\n          return ctrl.tableState().search;\n        }, function (newValue, oldValue) {\n          var predicateExpression = attr.stSearch || '$';\n          if (newValue.predicateObject && $parse(predicateExpression)(newValue.predicateObject) !== element[0].value) {\n            element[0].value = $parse(predicateExpression)(newValue.predicateObject) || '';\n          }\n        }, true);\n\n        // view -> table state\n        element.bind(event, function (evt) {\n          evt = evt.originalEvent || evt;\n          if (promise !== null) {\n            $timeout.cancel(promise);\n          }\n\n          promise = $timeout(function () {\n            var input = evt.target.value;\n            input = ng.isString(input) && trimSearch ? input.trim() : input;\n            tableCtrl.search(input, attr.stSearch || '');\n            promise = null;\n          }, throttle);\n        });\n      }\n    };\n  }]);\n\nng.module('smart-table')\n  .directive('stSelectRow', ['stConfig', function (stConfig) {\n    return {\n      restrict: 'A',\n      require: '^stTable',\n      scope: {\n        row: '=stSelectRow'\n      },\n      link: function (scope, element, attr, ctrl) {\n        var mode = attr.stSelectMode || stConfig.select.mode;\n        element.bind('click', function () {\n          scope.$apply(function () {\n            ctrl.select(scope.row, mode);\n          });\n        });\n\n        scope.$watch('row.isSelected', function (newValue) {\n          if (newValue === true) {\n            element.addClass(stConfig.select.selectedClass);\n          } else {\n            element.removeClass(stConfig.select.selectedClass);\n          }\n        });\n      }\n    };\n  }]);\n\nng.module('smart-table')\n  .directive('stSort', ['stConfig', '$parse', '$timeout', function (stConfig, $parse, $timeout) {\n    return {\n      restrict: 'A',\n      require: '^stTable',\n      link: function (scope, element, attr, ctrl) {\n\n        var predicate = attr.stSort;\n        var getter = $parse(predicate);\n        var index = 0;\n        var classAscent = attr.stClassAscent || stConfig.sort.ascentClass;\n        var classDescent = attr.stClassDescent || stConfig.sort.descentClass;\n        var stateClasses = [classAscent, classDescent];\n        var sortDefault;\n        var skipNatural = attr.stSkipNatural !== undefined ? attr.stSkipNatural : stConfig.sort.skipNatural;\n        var descendingFirst = attr.stDescendingFirst !== undefined ? attr.stDescendingFirst : stConfig.sort.descendingFirst;\n        var promise = null;\n        var throttle = attr.stDelay || stConfig.sort.delay;\n\n        // set aria attributes\n        var ariaSort = 'aria-sort';\n        var ariaSortNone = 'none';\n        var ariaSortAscending = 'ascending';\n        var ariaSortDescending = 'descending';\n        element\n          .attr('role', 'columnheader')\n          .attr(ariaSort, ariaSortNone);\n\n        if (attr.stSortDefault) {\n          sortDefault = scope.$eval(attr.stSortDefault) !== undefined ? scope.$eval(attr.stSortDefault) : attr.stSortDefault;\n        }\n\n        //view --> table state\n        function sort () {\n          if (descendingFirst) {\n            index = index === 0 ? 2 : index - 1;\n          } else {\n            index++;\n          }\n\n          var func;\n          predicate = ng.isFunction(getter(scope)) || ng.isArray(getter(scope)) ? getter(scope) : attr.stSort;\n          if (index % 3 === 0 && !!skipNatural !== true) {\n            //manual reset\n            index = 0;\n            ctrl.tableState().sort = {};\n            ctrl.tableState().pagination.start = 0;\n            func = ctrl.pipe.bind(ctrl);\n          } else {\n            func = ctrl.sortBy.bind(ctrl, predicate, index % 2 === 0);\n          }\n          if (promise !== null) {\n            $timeout.cancel(promise);\n          }\n          if (throttle < 0) {\n            func();\n          } else {\n            promise = $timeout(function(){\n              func();\n            }, throttle);\n          }\n        }\n\n        element.bind('click', function sortClick () {\n          if (predicate) {\n            scope.$apply(sort);\n          }\n        });\n\n        if (sortDefault) {\n          index = sortDefault === 'reverse' ? 1 : 0;\n          sort();\n        }\n\n        //table state --> view\n        scope.$watch(function () {\n          return ctrl.tableState().sort;\n        }, function (newValue) {\n          if (newValue.predicate !== predicate) {\n            index = 0;\n            element\n              .removeClass(classAscent)\n              .removeClass(classDescent)\n              .attr(ariaSort, ariaSortNone);\n          } else {\n            index = newValue.reverse === true ? 2 : 1;\n            element\n              .removeClass(stateClasses[index % 2])\n              .addClass(stateClasses[index - 1])\n              .attr(ariaSort, newValue.reverse ? ariaSortAscending : ariaSortDescending);\n          }\n        }, true);\n      }\n    };\n  }]);\n\nng.module('smart-table')\n  .directive('stPagination', ['stConfig', function (stConfig) {\n    return {\n      restrict: 'EA',\n      require: '^stTable',\n      scope: {\n        stItemsByPage: '=?',\n        stDisplayedPages: '=?',\n        stPageChange: '&'\n      },\n      templateUrl: function (element, attrs) {\n        if (attrs.stTemplate) {\n          return attrs.stTemplate;\n        }\n        return stConfig.pagination.template;\n      },\n      link: function (scope, element, attrs, ctrl) {\n\n        scope.stItemsByPage = scope.stItemsByPage ? +(scope.stItemsByPage) : stConfig.pagination.itemsByPage;\n        scope.stDisplayedPages = scope.stDisplayedPages ? +(scope.stDisplayedPages) : stConfig.pagination.displayedPages;\n\n        scope.currentPage = 1;\n        scope.pages = [];\n\n        function redraw () {\n          var paginationState = ctrl.tableState().pagination;\n          var start = 1;\n          var end;\n          var i;\n          var prevPage = scope.currentPage;\n          scope.totalItemCount = paginationState.totalItemCount;\n          scope.currentPage = Math.floor(paginationState.start / paginationState.number) + 1;\n          scope.stItemsByPage = paginationState.number;\n\n          start = Math.max(start, scope.currentPage - Math.abs(Math.floor(scope.stDisplayedPages / 2)));\n          end = start + scope.stDisplayedPages;\n\n          if (end > paginationState.numberOfPages) {\n            end = paginationState.numberOfPages + 1;\n            start = Math.max(1, end - scope.stDisplayedPages);\n          }\n\n          scope.pages = [];\n          scope.numPages = paginationState.numberOfPages;\n\n          for (i = start; i < end; i++) {\n            scope.pages.push(i);\n          }\n\n          if (prevPage !== scope.currentPage) {\n            scope.stPageChange({newPage: scope.currentPage});\n          }\n        }\n\n        //table state --> view\n        scope.$watch(function () {\n          return ctrl.tableState().pagination;\n        }, redraw, true);\n\n        //scope --> table state  (--> view)\n        scope.setItemsByPage = function (val) {\n          scope.stItemsByPage = val;\n          scope.selectPage(1);\n        }\n\n        scope.$watch('stDisplayedPages', redraw);\n\n        //view -> table state\n        scope.selectPage = function (page) {\n          if (page > 0 && page <= scope.numPages) {\n            ctrl.slice((page - 1) * scope.stItemsByPage, scope.stItemsByPage);\n          }\n        };\n\n        if (!ctrl.tableState().pagination.number) {\n          ctrl.slice(0, scope.stItemsByPage);\n        }\n      }\n    };\n  }]);\n\nng.module('smart-table')\n  .directive('stPipe', ['stConfig', '$timeout', function (config, $timeout) {\n    return {\n      require: 'stTable',\n      scope: {\n        stPipe: '='\n      },\n      link: {\n\n        pre: function (scope, element, attrs, ctrl) {\n\n          var pipePromise = null;\n\n          if (ng.isFunction(scope.stPipe)) {\n            ctrl.preventPipeOnWatch();\n            ctrl.pipe = function () {\n\n              if (pipePromise !== null) {\n                $timeout.cancel(pipePromise)\n              }\n\n              pipePromise = $timeout(function () {\n                scope.stPipe(ctrl.tableState(), ctrl);\n                if(element.context) ctrl.$window.scrollTo(0, element.context.offsetTop);\n              }, config.pipe.delay);\n\n              return pipePromise;\n            }\n          }\n        },\n\n        post: function (scope, element, attrs, ctrl) {\n          ctrl.pipe();\n        }\n      }\n    };\n  }]);\n\n})(angular);"]}